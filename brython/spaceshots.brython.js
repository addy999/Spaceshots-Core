__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1613260873348, "spaceshots.game": [".py", "import time\n\nfrom .assests import *\nfrom .scene import *\nfrom .physics import *\n\n\nclass Game:\n def __init__(self,fps=60.0,scenes=list,reset=True ):\n \n  assert fps >0,\"Game must have an FPS!\"\n  \n  self.fps=fps\n  self.dt=1 /fps\n  self.scenes=scenes\n  \n  \n  if reset:\n   self.reset()\n  else :\n   self.current_scene=self.scenes[0]\n   \n def control_sc(self,command=int):\n \n  ''\n  \n  if command in [0,1,2,3,4]:\n  \n   if command !=0:\n    self.current_scene.sc.thrust=True\n    if command ==1:\n     self.current_scene.sc.thrust_direction=\"+y\"\n    elif command ==2:\n     self.current_scene.sc.thrust_direction=\"-x\"\n    elif command ==3:\n     self.current_scene.sc.thrust_direction=\"-y\"\n    else :\n     self.current_scene.sc.thrust_direction=\"+x\"\n     \n   else :\n    self.current_scene.sc.thrust=False\n    \n def check_status(self):\n \n  sc=self.current_scene.sc\n  screen_x=self.current_scene.size[0]\n  screen_y=self.current_scene.size[1]\n  win_region_1=self.current_scene.win_region[0]\n  win_region_2=self.current_scene.win_region[1]\n  won=False\n  failed=False\n  message=\"\"\n  \n  \n  if win_region_1[0]==win_region_2[0]:\n   if (win_region_1[0]==0.0 and sc.x <=0)or (\n   win_region_1[0]==screen_x and sc.x >=screen_x\n   ):\n    if (\n    win_region_1[1]<=sc.y <=win_region_2[1]\n    and sc.vel.mag >=self.current_scene.win_min_velocity\n    ):\n     won=True\n     message=\"Won!\"\n     \n     \n  if win_region_1[1]==win_region_2[1]:\n   if (win_region_1[1]==0.0 and sc.y <=0)or (\n   win_region_1[1]==screen_y and sc.y >=screen_y\n   ):\n    if (\n    win_region_1[0]<=sc.x <=win_region_2[0]\n    and sc.vel.mag >=self.current_scene.win_min_velocity\n    ):\n     won=True\n     message=\"Won!\"\n     \n     \n  if not won and (\n  not 0.0 <sc.x <self.current_scene.size[0]\n  or not 0.0 <sc.y <self.current_scene.size[1]\n  ):\n   failed=True\n   message=\"Failed: Out of bounds.\"\n   \n   \n  if not failed:\n   for planet in self.current_scene.planets:\n    if sc.intersects(planet):\n     failed=True\n     message=\"Failed: Collision.\"\n     \n  return won,failed,message\n  \n def set_next_scene(self):\n \n  if self.current_scene.won:\n  \n   current_i=self.scenes.index(self.current_scene)\n   \n   if current_i <len(self.scenes)-1:\n    self.current_scene=self.scenes[current_i+1]\n   else :\n    self.done=True\n    \n def _scene_won(self):\n \n  self.current_scene.won=True\n  self.current_scene.attempts +=1\n  self.set_next_scene()\n  self.current_scene.reset_pos()\n  \n def _scene_failed(self):\n \n  self.current_scene.reset_pos()\n  self.current_scene.attempts +=1\n  \n def calc_score(self):\n \n  gas_bonus=0.0\n  total=0.0\n  \n  for scene in self.scenes:\n   if scene.won:\n    total +=scene.completion_score\n    if scene.attempts >1:\n     total -=(scene.attempts -1)*scene.attempt_score_reduction\n    if scene.attempts >=1:\n     gas_left=scene.sc.gas_level /scene.sc._initial_gas_level\n     gas_bonus +=gas_left *scene.gas_bonus_score\n     total +=gas_bonus\n     \n  if total <0:\n   total=0.0\n   \n  return total,gas_bonus\n  \n def reset(self):\n \n  [s.reset()for s in self.scenes]\n  self.current_scene=self.scenes[0]\n  self.done=False\n  \n def wait(self,time_to_remove):\n \n  dt=self.dt -time_to_remove\n  if dt <0:\n   dt=0\n   \n  time.sleep(dt)\n  \n def step(self,command=int,wait=False ):\n \n  start=time.time()\n  self.control_sc(command)\n  self.current_scene.update_all_pos(self.dt)\n  level_won,level_failed,message=self.check_status()\n  \n  if level_won:\n   self._scene_won()\n  elif level_failed:\n   self._scene_failed()\n   \n  time_elapsed=time.time()-start\n  \n  if wait:\n   self.wait(time_elapsed)\n   \n  return level_won,level_failed,message\n  \n def save_state(self):\n \n  to_return=\"\"\n  to_return +=str(self.fps)+\"+\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n", ["spaceshots.assests", "spaceshots.physics", "spaceshots.scene", "time"]], "spaceshots.scene": [".py", "import math\nimport time\n\nfrom random import randint,choices,uniform\nfrom .assests import *\nfrom .physics import *\nfrom .utils import *\n\n\nclass Scene:\n def __init__(\n self,\n size,\n spacecraft,\n planets,\n \n win_region=tuple,\n win_velocity=0.0,\n completion_score=100,\n attempt_score_reduction=5,\n gas_bonus_score=10,\n reset=True ,\n ):\n \n  self.size=size\n  self.sc=spacecraft\n  self.planets=planets\n  self.sc_start_pos=self.sc.x,self.sc.y\n  self.sc.min_dist_to_planet=min(*self.size)*0.75\n  \n  self.win_region=win_region\n  self.win_min_velocity=round_to_nearest(win_velocity,10)\n  self.attempts=0\n  self.won=False\n  self.fail=False\n  \n  self.completion_score=round_to_nearest(completion_score,5)\n  self.attempt_score_reduction=round_to_nearest(attempt_score_reduction,5)\n  self.gas_bonus_score=round_to_nearest(gas_bonus_score,5)\n  \n  \n  \n  \n  \n  \n  self.initial_orbit_pos=[planet.orbit.progress for planet in planets]\n  \n  if reset:\n   self.reset_pos()\n   \n def _set_sc_default_start_pos(self):\n  ''\n\n  \n  \n  return self.size[0]/2,self.sc.length /2\n  \n def reset_pos(self):\n \n  self.sc.reset(self.sc_start_pos)\n  \n  for i in range(len(self.planets)):\n   self.planets[i].orbit.progress=self.initial_orbit_pos[i]\n   \n def reset(self):\n \n  self.reset_pos()\n  self.attempts=0\n  self.won=False\n  \n def update_all_pos(self,impulse_time):\n \n  [planet.move(impulse_time)for planet in self.planets]\n  self.sc.update_pos(impulse_time,self.planets,False )\n  \n def save_state(self):\n \n  return \"+\".join(self.__dict__.values())\n  \n def __repr__(self):\n  print(str(vars(self)),width=100,indent=5,depth=4)\n  return \"\"\n  \n  \nclass LevelBuilder:\n\n ''\n\n \n \n def __init__(self,x_size,y_size,timeout=5):\n \n  self.x_size=x_size\n  self.y_size=y_size\n  self.size=self.x_size *self.y_size\n  self.diag=(self.x_size **2+self.y_size **2)**0.5\n  self.padding=min(x_size,y_size)/8\n  self.timeout=timeout\n  self.poly=RectPolygon((0,y_size),(x_size,0))\n  \n  \n  \n  self.easy=dict(\n  planet=dict(n=(1,1),mass=(3e16,4e16)),\n  orbit=dict(\n  a=(x_size /3,x_size /2),\n  b=(y_size /3,y_size /2),\n  angular_step=(2 *math.pi /200,2 *math.pi /200),\n  center_x=(0,self.x_size),\n  center_y=(0,self.y_size /2),\n  ),\n  sc=dict(\n  mass=(100,125),\n  gas_level=(350,450),\n  thrust_force=(3000,3000),\n  size=(self.size *30 /(942 *539),self.size *35 /(942 *539)),\n  start_pos=(\n  (self.x_size /4,self.x_size *0.75),\n  (0,self.y_size *0.3),\n  ),\n  ),\n  scene=dict(\n  win_region_length=sorted((self.x_size /2,self.y_size /2)),\n  win_region_pos_prob=[0.1,0.8,0.1,0],\n  win_velocity=(90,125),\n  completion_score=(50,100),\n  attempt_score_reduction=(1,3),\n  gas_bonus_score=(5,5),\n  ),\n  )\n  self.medium=dict(\n  planet=dict(n=(1,2),mass=(4e16,5e16)),\n  orbit=dict(\n  a=(x_size /4,x_size *0.75),\n  b=(y_size /4,y_size *0.75),\n  angular_step=(1.5 *math.pi /200,3 *math.pi /200),\n  center_x=(0,self.x_size),\n  center_y=(0,self.y_size),\n  ),\n  sc=dict(\n  mass=(100,125),\n  gas_level=(300,450),\n  thrust_force=(3500,4500),\n  size=(self.size *30 /(942 *539),self.size *35 /(942 *539)),\n  start_pos=(\n  (self.x_size /4,self.x_size *0.75),\n  (0,self.y_size *0.3),\n  ),\n  ),\n  scene=dict(\n  win_region_length=sorted((self.x_size /3,self.y_size /3)),\n  win_region_pos_prob=[1 /3,1 /3,1 /3,0],\n  win_velocity=(100,150),\n  completion_score=(100,150),\n  attempt_score_reduction=(5,7),\n  gas_bonus_score=(10,15),\n  ),\n  )\n  self.hard=dict(\n  planet=dict(n=(1,2),mass=(4e16,5e16)),\n  orbit=dict(\n  a=(x_size /4,x_size *0.75),\n  b=(y_size /4,y_size *0.75),\n  angular_step=(1.5 *math.pi /200,3 *math.pi /200),\n  center_x=(0,self.x_size),\n  center_y=(0,self.y_size),\n  ),\n  sc=dict(\n  mass=(100,125),\n  gas_level=(300,450),\n  thrust_force=(3500,4500),\n  size=(self.size *30 /(942 *539),self.size *35 /(942 *539)),\n  start_pos=(\n  (self.x_size /4,self.x_size *0.75),\n  (self.y_size /4,self.y_size *0.75),\n  ),\n  ),\n  scene=dict(\n  win_region_length=sorted((self.x_size /3,self.y_size /3)),\n  win_region_pos_prob=[1 /3,0,1 /3,1 /3],\n  win_velocity=(100,150),\n  completion_score=(100,150),\n  attempt_score_reduction=(5,7),\n  gas_bonus_score=(10,15),\n  ),\n  )\n  \n def generate_win_region(self,pos,length):\n \n  ''\n  \n  if pos ==0:\n   p1=[0,uniform(self.y_size /3,self.y_size *0.75)]\n   p2=[0,clip(p1[1]+length,None ,self.y_size)]\n   \n  if pos ==1:\n  \n   p1=[uniform(0,self.x_size /2),self.y_size]\n   p2=[clip(p1[0]+length,None ,self.x_size),self.y_size]\n   \n  if pos ==2:\n   p1=[self.x_size,uniform(self.y_size /3,self.y_size *0.75)]\n   p2=[self.x_size,clip(p1[1]+length,None ,self.y_size)]\n   \n  if pos ==3:\n  \n   p1=[uniform(0,self.x_size /2),0]\n   p2=[clip(p1[0]+length,None ,self.x_size),0]\n   \n  return p1,p2\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def create(self,option):\n \n  start=time.time()\n  init_config=dict_to_class(self.__dict__[option.lower()])\n  \n  \n  orbits=[]\n  n=randint(*init_config.planet.n)\n  orbits_valid=False\n  dur=0\n  while not orbits_valid and dur <=self.timeout:\n   s=time.time()\n   orbits=OrbitCollection(\n   [\n   Orbit(\n   uniform(*init_config.orbit.a),\n   uniform(*init_config.orbit.b),\n   uniform(*init_config.orbit.center_x),\n   uniform(*init_config.orbit.center_y),\n   progress=uniform(0,2 *math.pi),\n   angular_step=uniform(*init_config.orbit.angular_step),\n   )\n   for i in range(n)\n   ]\n   )\n   orbits_valid=orbits.orbits_valid(\n   uniform(self.x_size /2,self.y_size /2),\n   uniform(self.diag /2,self.diag *0.75),\n   )\n   dur +=time.time()-s\n   \n   \n  size=uniform(*init_config.sc.size)\n  sc=Spacecraft(\n  \"\",\n  uniform(*init_config.sc.mass),\n  uniform(*init_config.sc.gas_level),\n  uniform(*init_config.sc.thrust_force),\n  width=size,\n  length=size,\n  x=uniform(*init_config.sc.start_pos[0]),\n  y=clip(uniform(*init_config.sc.start_pos[1]),size /2,None ),\n  )\n  \n  \n  planets=[\n  Planet(name=\"\",mass=uniform(*init_config.planet.mass),orbit=orbit)\n  for orbit in orbits.orbits\n  ]\n  \n  \n  orbits.adjust_dir_to_screen(self.x_size,self.y_size)\n  \n  \n  win_region=self.generate_win_region(\n  choices([0,1,2,3],weights=init_config.scene.win_region_pos_prob),\n  uniform(*init_config.scene.win_region_length),\n  )\n  scene=Scene(\n  (self.x_size,self.y_size),\n  sc,\n  planets,\n  win_region=win_region,\n  win_velocity=uniform(*init_config.scene.win_velocity),\n  completion_score=randint(*init_config.scene.completion_score),\n  attempt_score_reduction=randint(*init_config.scene.attempt_score_reduction),\n  gas_bonus_score=randint(*init_config.scene.gas_bonus_score),\n  )\n  \n  print(\"Took\",time.time()-start)\n  return scene\n", ["math", "random", "spaceshots.assests", "spaceshots.physics", "spaceshots.utils", "time"]], "spaceshots.api": [".py", "from .game import Game\nfrom .scene import LevelBuilder\nfrom random import randint\n\ngame=None\nstatus={}\n\n\ndef create_level_difficulties(max_difficulty:str,n_levels:int):\n\n _map={0:\"easy\",1:\"medium\",2:\"hard\"}\n \n max_level=2\n \n if max_difficulty ==\"medium\":\n  _map.pop(2)\n  max_level=1\n elif max_difficulty ==\"easy\":\n  _map.pop(2)\n  _map.pop(1)\n  max_level=0\n  \n  \n  \n return [\n _map[randint(0,max_level)]if i >0 else \"easy\"for i in range(n_levels)\n ]\n \n \ndef create_game(\nscreen_x:float,screen_y:float,hardest_difficulty=\"hard\",n_levels=5,fps=60\n):\n\n global game\n global status\n \n builder=LevelBuilder(screen_x,screen_y)\n levels=[\n builder.create(diff)\n for diff in create_level_difficulties(hardest_difficulty,n_levels)\n ]\n game=Game(scenes=levels,fps=fps)\n status={}\n \n \ndef step(thrust_dir)->None :\n\n global game\n global status\n \n won,fail,message=game.step(thrust_dir)\n status=dict(won=won,fail=fail,message=message)\n", ["random", "spaceshots.game", "spaceshots.scene"]], "spaceshots": [".py", "__name__=\"spaceshots_core\"\n__version__=\"0.1\"\n\n\n\n\n\n\nfrom .game import Game\nfrom .scene import LevelBuilder,Scene as Level\n", ["spaceshots.game", "spaceshots.scene"], 1], "spaceshots.utils": [".py", "def dict_to_class(_dict):\n ''\n \n class dotdict(dict):\n  ''\n  \n  __getattr__=dict.get\n  __setattr__=dict.__setitem__\n  __delattr__=dict.__delitem__\n  \n for i in _dict:\n  if type(_dict[i])==dict:\n   _dict[i]=dotdict(_dict[i])\n   \n return dotdict(_dict)\n \n \ndef round_to_nearest(num,nearest):\n return round(num /nearest)*nearest\n \n \ndef closest_dist_to_sc(sc,planets):\n\n min_dist=1e6\n for planet in planets:\n  dist=sc.calc_distance(planet)\n  if dist <min_dist:\n   min_dist=dist\n   \n return min_dist\n \n \ndef vector_norm(array:list)->float:\n return sum([i **2 for i in array])**0.5\n \n \ndef add_two_vectors(v1:list,v2:list)->list:\n return [i+j for i,j in zip(v1,v2)]\n \n \ndef subtract_two_vectors(v1:list,v2:list)->list:\n return [i -j for i,j in zip(v1,v2)]\n \n \ndef euclidian_distance(v1,v2):\n return vector_norm(subtract_two_vectors(v1,v2))\n \n \ndef clip(val,min_val=None ,max_val=None )->float:\n\n new_val=val\n \n if min_val and val <min_val:\n  new_val=min_val\n  \n if max_val and val >max_val:\n  new_val=max_val\n  \n return new_val\n", []], "spaceshots.physics": [".py", "import math\n\nfrom .utils import *\n\nG=6.67408e-11\n\n\nclass Velocity:\n def __init__(self,x_vel,y_vel):\n \n  self.x=x_vel\n  self.y=y_vel\n  self.vec=[self.x,self.y]\n  self.rot_matrix=get_rot_matrix(self.get_theta())\n  self.mag=(self.x **2+self.y **2)**0.5\n  self.theta=self.get_theta()\n  \n def get_theta(self):\n \n  angle=angle_between([1,0],self.vec)\n  \n  \n  \n  return angle\n  \n def __repr__(self):\n \n  return str((self.x,self.y))\n  \n  \nclass Force:\n def __init__(self,x_vector,y_vector,mag):\n \n  ratio,mag=self._create_ratio(x_vector,y_vector,mag)\n  self.x=x_vector *ratio\n  self.y=y_vector *ratio\n  self.mag=mag\n  \n def _create_ratio(self,x_vector,y_vector,mag):\n \n  hyp=(x_vector **2+y_vector **2)**0.5\n  \n  if hyp !=0.0:\n   ratio=mag /hyp\n  else :\n   ratio=0.0\n   mag=0.0\n   \n  return ratio,mag\n  \n def __add__(self,new):\n \n  self.x +=new.x\n  self.y +=new.y\n  self.mag=(self.x **2+self.y **2)**0.5\n  \n  return self\n  \n def __repr__(self):\n \n  return str((self.x,self.y))\n  \n  \nclass Momentum:\n def __init__(self,x_vel,y_vel,mass=1):\n \n  self.x=mass *x_vel\n  self.y=mass *y_vel\n  \n @classmethod\n def from_impulse(cls,force=Force,duration=float):\n \n  x=force.x *duration\n  y=force.y *duration\n  \n  return cls(x,y)\n  \n def save_state(self):\n \n  return \"+\".join(self.__dict__.values())\n  \n def __add__(self,new):\n \n  self.x +=new.x\n  self.y +=new.y\n  \n  return self\n  \n def __repr__(self):\n \n  return str((self.x,self.y))\n  \n  \nclass Orbit:\n def __init__(\n self,a,b,center_x,center_y,progress=0.0,CW=True ,angular_step=3.14 /900\n ):\n  self.a=a\n  self.b=b\n  self.center_x=center_x\n  self.center_y=center_y\n  self.progress=progress\n  self._ang_step=angular_step\n  self.cw=CW\n  \n  self.make_poly(a,b,center_x,center_y)\n  self.change_angular_step(angular_step)\n  \n def make_poly(self,a,b,center_x,center_y):\n \n \n  self.poly=RectPolygon(\n  [center_x -a,center_y+b],\n  [center_x+a,center_y -b],\n  )\n  \n def change_angular_step(self,angular_step=float):\n  self.angular_step=angular_step %2 *math.pi\n  \n def set_progress(self,pos):\n  self.progress=math.acos((pos[0]-self.center_x)/self.a)\n  \n def x(self,progress):\n \n \n  return self.a *math.cos(progress)+self.center_x\n  \n def y(self,progress):\n \n \n  return self.b *math.sin(progress)+self.center_y\n  \n def get_pos(self):\n  return self.x(self.progress),self.y(self.progress)\n  \n def next_pos(self,factor=1.0):\n \n  if self.cw:\n   self.progress +=self.angular_step *factor\n  else :\n   self.progress -=self.angular_step *factor\n   \n  return self.get_pos()\n  \n def prev_pos(self,factor=1.0):\n  self.next_pos(-factor)\n  \n def reset_pos(self):\n  self.progress=0\n  return self.x(self.progress),self.y(self.progress)\n  \n def __repr__(self):\n  return str(vars(self))\n  \n  \nclass OrbitCollection:\n def __init__(self,orbits):\n \n  self.orbits=orbits\n  \n def orbits_valid(self,min_distance,max_distance):\n  for o in self.orbits:\n   for j in self.orbits:\n    if o !=j:\n     if o.poly.intersects(j.poly):\n      return False\n      \n     dist_between=o.poly.distance_to(j.poly)\n     if dist_between <min_distance or dist_between >max_distance:\n      return False\n  return True\n  \n def adjust_dir_to_sc(self,sc_pos):\n  for o in self.orbits:\n   current_dist=euclidian_distance(o.get_pos(),sc_pos)\n   o.next_pos(5)\n   next_dist=euclidian_distance(o.get_pos(),sc_pos)\n   \n   if next_dist >current_dist:\n   \n   \n    o.cw=not o.cw\n    \n def adjust_dir_to_screen(self,x_screen,y_screen):\n  center=(x_screen /2,y_screen /2)\n  for o in self.orbits:\n   current_dist=euclidian_distance(o.get_pos(),center)\n   o.next_pos(1)\n   next_dist=euclidian_distance(o.get_pos(),center)\n   o.prev_pos(1)\n   \n   if next_dist >current_dist:\n   \n    o.cw=not o.cw\n    \n    \n def adjust_cw_dir(self,screen_size):\n \n  for o in self.orbits:\n   x,y=o.get_pos()\n   if x <=screen_size[0]/2:\n    o.cw=True\n   else :\n    o.cw=False\n    \n    \ndef distance_between_points(p1,p2)->float:\n\n new_vec=[j -i for i,j in zip(p1,p2)]\n return vector_norm(new_vec)\n \n \nclass CirclePolygon:\n def __init__(self,center_x:float,center_y:float,r:float):\n \n  self.x=center_x\n  self.y=center_y\n  self.r=r\n  \n def intersects(self,other_poly)->bool:\n \n  if isinstance(other_poly,CirclePolygon):\n  \n   return (\n   distance_between_points([self.x,self.y],[other_poly.x,other_poly.y])\n   <=self.r+other_poly.r\n   )\n   \n   \nclass RectPolygon:\n def __init__(self,tl:list,br:list)->None :\n  self.tl=tl\n  self.br=br\n  \n def intersects(self,other_rect):\n \n  ''\n\n  \n  \n  if isinstance(other_rect,RectPolygon):\n  \n  \n   if self.tl[0]>=other_rect.br[0]or other_rect.tl[0]>=self.br[0]:\n    return False\n    \n    \n   if self.tl[1]<=other_rect.br[1]or other_rect.tl[1]<=self.br[1]:\n    return False\n    \n   return True\n   \n def distance_to(self,other_rect):\n \n  ''\n\n  \n  \n  if isinstance(other_rect,RectPolygon):\n  \n   x1,y1,x1b,y1b=self.tl+self.br\n   x2,y2,x2b,y2b=other_rect.tl+other_rect.br\n   \n   left=x2b <x1\n   right=x1b <x2\n   bottom=y2b <y1\n   top=y1b <y2\n   if top and left:\n    return vector_norm((x1,y1b),(x2b,y2))\n   elif left and bottom:\n    return vector_norm((x1,y1),(x2b,y2b))\n   elif bottom and right:\n    return vector_norm((x1b,y1),(x2,y2b))\n   elif right and top:\n    return vector_norm((x1b,y1b),(x2,y2))\n   elif left:\n    return x1 -x2b\n   elif right:\n    return x2 -x1b\n   elif bottom:\n    return y1 -y2b\n   elif top:\n    return y2 -y1b\n   else :\n    return 0.0\n    \n    \ndef unit_vector(vector):\n ''\n norm=vector_norm(vector)\n if norm >0:\n  return vector /norm\n else :\n  return [0.0,0.0]\n  \n  \ndef get_rot_matrix(theta:float)->list:\n\n return [[math.cos(theta),-math.sin(theta)],[math.sin(theta),math.cos(theta)]]\n \n \ndef dot(v1:list,v2:list)->float:\n ''\n\n\n\n\n\n\n\n \n \n return sum([i *j for i,j in zip(v1,v2)])\n \n \ndef matmul(X,Y):\n\n return [\n [sum(a *b for a,b in zip(X_row,Y_col))for Y_col in zip(*Y)]for X_row in X\n ]\n \n \ndef rotate(theta,vec,custom=False ):\n\n ''\n\n\n\n\n\n\n \n \n rot_matrix=get_rot_matrix(theta)\n return matmul(rot_matrix,[[i]for i in vec])\n \n \ndef angle_between(v1,v2):\n ''\n\n\n\n\n\n\n\n \n v1_u=unit_vector(v1)\n v2_u=unit_vector(v2)\n return math.acos(clip(dot(v1_u,v2_u),-1.0,1.0))\n", ["math", "spaceshots.utils"]], "spaceshots.assests": [".py", "import math\n\nfrom .physics import *\nfrom .utils import *\n\n\nclass Asset:\n def __init__(self,name,x=0.0,y=0.0,mass=0,vel=None ):\n \n  self.x=x\n  self.y=y\n  self.name=name\n  self.mass=mass\n  self.vel=vel\n  if not vel:\n   self.vel=Velocity(0.0,0.0)\n   \n  self.poly=None\n  self._p=Momentum(self.vel.x,self.vel.y,self.mass)\n  \n def reset_pos(self):\n \n  self.x=0\n  self.y=0\n  \n def pos(self):\n  return self.x,self.y\n  \n def calc_distance(self,other_asset):\n \n  return sum([x **2 for x in self.calc_vector(other_asset)])**0.5\n  \n def calc_vector(self,other_asset):\n \n  dx=other_asset.x -self.x\n  dy=other_asset.y -self.y\n  \n  return dx,dy\n  \n def calc_gravitational_force(self,other_asset):\n \n  M=self.mass\n  m=other_asset.mass\n  r=self.calc_distance(other_asset)\n  \n  mag=G *M *m /r **2\n  x,y=self.calc_vector(other_asset)\n  \n  return Force(x,y,mag)\n  \n def intersects(self,other_asset):\n  return self.poly.intersects(other_asset.poly)\n  \n @property\n def p(self):\n  return self._p\n  \n @p.setter\n def p(self,val):\n  self._p=val\n  self.vel=Velocity(val.x /self.mass,val.y /self.mass)\n  \n def __repr__(self):\n  return str(vars(self))\n  \n  \nclass Planet(Asset):\n def __init__(self,name,mass=0.0,orbit=Orbit,radius_per_kilogram=45 /4e16):\n \n  super().__init__(name,0.0,0.0,mass)\n  self.orbit=orbit\n  self.radius=radius_per_kilogram *mass\n  self.move()\n  \n def make_poly(self):\n  self.poly=CirclePolygon(self.x,self.y,self.radius)\n  \n def move(self,dt=1.0):\n  self.x,self.y=self.orbit.next_pos(dt)\n  self.make_poly()\n  return self.pos()\n  \n def save_state(self):\n  return \"+\".join(self.__dict__.values())\n  \n  \n  \n  \nclass Spacecraft(Asset):\n def __init__(\n self,\n name,\n mass=0.0,\n gas_level=0.0,\n thrust_force=0.0,\n width=10,\n length=10,\n gas_per_thrust=1 /1000,\n min_dist_to_planet=1000,\n x=0.0,\n y=0.0,\n ):\n \n  super().__init__(name,x,y,mass)\n  self._theta=0.0\n  self.gas_level=round_to_nearest(gas_level,10)\n  self._initial_gas_level=self.gas_level\n  self.thrust=False\n  self.thrust_direction=\"-y\"\n  self.thrust_mag=thrust_force\n  self.width=width\n  self.length=length\n  self.gas_per_thrust=gas_per_thrust\n  self.min_dist_to_planet=min_dist_to_planet\n  self.draw_poly()\n  \n def draw_poly(self):\n  effective_radius=self.width /2+self.length /2\n  self.poly=CirclePolygon(self.x,self.y,effective_radius)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def get_thrust_impulse(self,time):\n \n  if self.gas_level <=0.0:\n   self.gas_level=0.0\n   self.thrust=False\n   \n  if self.thrust:\n  \n   self.gas_level -=round(self.thrust_mag *self.gas_per_thrust)\n   \n   \n   body_vec=rotate(self.theta,[1,0])\n   if vector_norm(self.vel.vec)==0.0:\n   \n    body_vec=[1,0]\n    \n   if self.thrust_direction ==\"-y\":\n    vector=rotate(math.pi *1.5,body_vec)\n   elif self.thrust_direction ==\"+y\":\n    vector=rotate(math.pi /2,body_vec)\n   elif self.thrust_direction ==\"-x\":\n    vector=rotate(math.pi,body_vec)\n   elif self.thrust_direction ==\"+x\":\n    vector=rotate(0.0,body_vec)\n    \n   force=Force(vector[0],vector[1],self.thrust_mag)\n   return Momentum.from_impulse(force,time)\n   \n  return Momentum(0.0,0.0)\n  \n def set_net_momentum(self,impulse_time,external_force=None ):\n \n \n  thrust_i=self.get_thrust_impulse(impulse_time)\n  \n  \n  if external_force:\n   external_i=Momentum.from_impulse(external_force,impulse_time)\n  else :\n   external_i=Momentum(0.0,0.0)\n   \n  self.p=self.p+thrust_i+external_i\n  \n def find_closest_planet(self,planets=list):\n \n  current_distance=self.calc_distance(planets[0])\n  \n  \n  index_of_closest=0\n  current_index=0\n  for num in range(len(planets)):\n   if self.calc_distance(planets[current_index])<current_distance:\n    index_of_closest=current_index\n    current_distance=self.calc_distance(planets[current_index])\n   current_index +=1\n   \n   \n   \n   \n   \n  return planets[index_of_closest]\n  \n def update_pos(self,impulse_time=float,planets=list,closest_only=True ):\n \n  planet_f=Force(0,0,0)\n  \n  if closest_only:\n   closes_planet=self.find_closest_planet(planets)\n   if closes_planet:\n    planet_f=self.calc_gravitational_force(closes_planet)\n  else :\n   for planet in planets:\n    planet_f +=self.calc_gravitational_force(planet)\n    \n  self.set_net_momentum(impulse_time,planet_f)\n  self.move(impulse_time)\n  \n  return self.x,self.y\n  \n def move(self,time):\n \n  self.x +=self.vel.x *time\n  self.y +=self.vel.y *time\n  \n def reset(self,sc_start_pos=None ):\n \n  self.thrust=False\n  if sc_start_pos:\n   self.x,self.y=sc_start_pos\n  self.p=Momentum(0.0,0.0)\n  self.gas_level=self._initial_gas_level\n  \n def save_state(self):\n \n  dict_={i:j for i,j in self.__dict__.items()if i !=\"poly\"}\n  return \"+\".join(dict_.values())\n  \n  \n  \n  \n  \n  \n  \n  \n  \n @property\n def theta(self):\n  return self._theta\n  \n @theta.setter\n def theta(self,vel_theta):\n \n  old_val=self._theta\n  \n  if abs(vel_theta -old_val)<math.pi *2:\n   self._theta=vel_theta -math.pi *0.5\n  else :\n   self._theta=vel_theta -math.pi *2 -math.pi *0.5\n   \n   \n   \n   \n   \n   \n @property\n def p(self):\n  return self._p\n  \n @p.setter\n def p(self,val):\n  self._p=val\n  self.vel=Velocity(val.x /self.mass,val.y /self.mass)\n  self.theta=self.vel.theta\n  self.draw_poly()\n", ["math", "spaceshots.physics", "spaceshots.utils"]]}
__BRYTHON__.update_VFS(scripts)
